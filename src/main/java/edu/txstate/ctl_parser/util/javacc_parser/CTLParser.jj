/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CTLParser.jj */
/*@egen*//**
*  @author Borislav Sabotinov
*
*  From Logic in Computer Science, Modeling and Reasoning About Systems, 2nd Ed, page 208
*  CTL as defined in Backus Naur Form (BNF)
*  \u00cf\u2020 ::= \u00e2\u0160\u00a5|T| p | (\u00c2\u00ac\u00cf\u2020) | (\u00cf\u2020 \u00e2\u02c6\u00a7 \u00cf\u2020) | (\u00cf\u2020 \u00e2\u02c6\u00a8 \u00cf\u2020) | (\u00cf\u2020 \u00e2\u2020\u2019 \u00cf\u2020) | AX \u00cf\u2020 | EX \u00cf\u2020 |
*           AF \u00cf\u2020 | EF \u00cf\u2020 | AG \u00cf\u2020 | EG \u00cf\u2020 | A[\u00cf\u2020 U \u00cf\u2020] | E[\u00cf\u2020 U \u00cf\u2020]
*
* To ensure users can enter formulas using a standard English keyboard, here is the modified CTL BNF:
*  phi ::= false|true| p | (~phi) | (phi & phi) | (phi | phi) | (phi -> phi) | AX phi | EX phi |
*           AF phi | EF phi | AG phi | EG phi | A[phi U phi] | E[phi U phi]
*  where p ranges over a set of atomic formulas.
*
* JJTree is a preprocessor for JavaCC that inserts actions into a JavaCC grammar to build parse trees for the input.
*/

options {
    JDK_VERSION         = "11";
    BUILD_PARSER        = true;
    BUILD_TOKEN_MANAGER = true;
    DEBUG_PARSER        = true;
    ERROR_REPORTING     = true;
    SANITY_CHECK        = true; // detect left recursion and ambiguity
    STATIC              = true; // only permit one parser
}

PARSER_BEGIN(CTLParser)

    package edu.txstate.ctl_parser.util.javacc_parser;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

public class CTLParser/*@bgen(jjtree)*/implements CTLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCTLParserState jjtree = new JJTCTLParserState();

/*@egen*/
    protected static JJTeg1State jjtree = new JJTeg1State();

    public static void main(String...args) throws ParseException {
        InputStreamReader converter = new InputStreamReader(System.in);
        BufferedReader in = new BufferedReader(converter);
        InputStream stream = new ByteArrayInputStream(new byte[0]);
        CTLParser parser = new CTLParser(stream);

        System.out.println("Reading from standard input...");
        System.out.println("A well formed formula (WFF) phi for Computational Tree Logic (CTL) may be in the form: ");
        System.out.println("phi ::= false | true | p | (~phi) | (phi & phi) | (phi | phi) | (phi -> phi) | AX phi | EX phi | "
                            + "\n AF phi | EF phi | AG phi | EG phi | A[phi U phi] | E[phi U phi]");
        System.out.print("Enter a WFF for CTL: ");

        try {
            stream = new ByteArrayInputStream(in.readLine().getBytes());
            parser.ReInit(stream);
            edu.txstate.ctl_parser.util.javacc_parser.ASTCTLFormula f = parser.Formula();
            f.dump("");
        } catch (Exception e) {
            System.err.println("An exception occurred!");
            System.err.println(e.getMessage());
            e.printStackTrace();
        } catch (Error e) {
            System.err.println("An error occurred!");
            System.err.println(e.getMessage());
        }
    } // end main
} // end class

PARSER_END(CTLParser)

/**
*  TOKEN MANAGER: Covers lexical states, lexical actions, and the use of special tokens.
*  https://javacc.github.io/javacc/tutorials/token-manager.html
*
* SKIP - simply throw away the matched string after executing any lexical action.
* Skip whitespace, return, tabs, and newline.
*/
SKIP : {
    " "
    | "\r"
    | "\t"
    | "\n"
}

/**
* TOKEN - create a token using the matched string and send it to the parser or any caller.
* NOT  may be represented with ~
* AND  may be represented with &
* OR   may be represented with |
* THEN may be represented with ->
*/
TOKEN : {
    < NOT : "~" >
}

TOKEN : {
    < AND : "&" >
    | < OR : "|" >
}

TOKEN : {
    < THEN : "->" >
}

TOKEN : {
    < ALL : "A" >
    | < EXISTS: "E" >
}

TOKEN : {
    < FUTURE : "F">
    | < GLOBALLY : "G">
    | < NEXT : "X" >
    | < UNTIL : "U" >
}

TOKEN : {
    < ATOM : ["a"-"z"](["a"-"z","0"-"9"])* >
}

ASTCTLFormula Formula():
{/*@bgen(jjtree) Formula */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMULA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Formula */
  try {
/*@egen*/
  Phi()< EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Phi()      :
{}
{
    Atom()
| "(" expr() ")"
| Connective()
}
void expr()      :
{/*@bgen(jjtree) Expr */
 SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Node n; int result=-1;}
{/*@bgen(jjtree) Expr */
  try {
/*@egen*/
  result=< NOT >.kind Phi()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setType(result); }
| Phi() result=exprPrime2() Phi()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setType(result); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
int exprPrime2()      :
{Token t;}
{
  t=< AND >
  {return t.kind;}
| t=< OR >
  {return t.kind;}
| t=< THEN >
  {return t.kind;}
}
void exprPrime()      :
{}
{
  < AND > Phi()
| < OR > Phi()
| < THEN > Phi()
}
void Connective()            :
{/*@bgen(jjtree) Connective */
 SimpleNode jjtn000 = new SimpleNode(JJTCONNECTIVE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/int path, temporal;}
{/*@bgen(jjtree) Connective */
  try {
/*@egen*/
  (
  path=< ALL >.kind temporal=connPart2()
| path=< EXISTS >.kind temporal=connPart2()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setType(path, temporal); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
int connPart2()      :
{int kind;}
{
  (
    kind=< NEXT >.kind Phi()
| kind=< FUTURE >.kind Phi()
| kind=< GLOBALLY >.kind Phi()
| "[" Phi() kind=< UNTIL >.kind Phi() "]"
  )
  { return kind; }
}

void Atom()      :
{/*@bgen(jjtree) Atom */
 SimpleNode jjtn000 = new SimpleNode(JJTATOM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Atom */
  try {
/*@egen*/
  t=< ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
	jjtn000.setName(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}